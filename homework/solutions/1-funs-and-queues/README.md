# Пет функцийки и една опашка

Най-добрият начин да се прихванат основите на нов език е чрез малки задачки. Затова сме ви подготвили няколко. Първото ви домашно е да имплементирате пет малки функции и да реализирате неизменяема опашка.

## `fromDigits` – Генериране на число от цифри

Реализирайте функция `fromDigits`, която от списък от цифри генерира число в бройна система с определена основа. Сигнатурата на функцията е следната:

```scala
def fromDigits(digits: List[Int], radix: Int = 10): Int
```

Реда на цифрите в списъка съвпада с реда на цифровия запис на числото – единиците са последният елемент, radix-иците (или десетиците) предпоследният, и т.н. Всяка цифра е представена в `digits` чрез числовата си стойност, така цифрата '5' е представена от числото 5, а цифрата 'B', която бихме срещнали в шестнайдесетична бройна система, чрез числото 11. Елементите на `digits` са числа между 0 и `radix`.

Примери:

```scala
fromDigits(List(1, 2, 3)) // 123
fromDigits(List(1, 12, 4), 16) // 452; съответства на шестнайдесетичното число 1C4
```

## `parseInteger` – Парсване на числов низ

Най-често бихме получили цифри чрез символен низ – въведен от потребителя, изпратен ни от някоя система, или по друг начин. Имплементирайте функция, която директно изчислява числената стойност на такива низове:

```scala
def parseInteger(integer: String, radix: Int = 10): Int
```

`integer` може да започва с незадължителния символ '-', а всички останали символи са цифри от 0 до 9 или букви от A до Z (съответства на регулярния израз `-?[0-9A-Z]+`). Числовата стойност на буквите е 10 за A, 11 за B, ..., 35 за Z. Така най-голямата възможна основа е 36. Ако `integer` започва с `-`, то резултатът е отрицанието на  числото, съответстващо на цифрите вдясно.

За реализиране на `parseInteger` не е позволено да използвате вградени в библиотеките на Scala и Java функции като `Integer.parseInt`, които вече извършват това.

Ако желаете, можете да превърнете даден низ в списък, използвайки метода [`toList`](https://www.scala-lang.org/api/current/scala/collection/immutable/StringOps.html#toList:List[A]).

Примери:

```scala
parseInteger("123") // 123
parseInteger("1C4", 16) // 452
parseInteger("-0111001", 2) // -57
```

## `zipMap` – Трансформация на елементите на два списъка едновременно

Често ни се налага да реализираме трансформации върху съчетани елементите от няколко източника, вместо само от един. Реализирайте функция `zipMap`, която приема два списъка `a` и `b` и функция на два параметъра `f` и генерира списък, формиран от прилаганията на `f` върху елементите на една и съща позиция в `a` и `b`. Списъците и функцията са върху цели числа.

Ако имаме списъци `List(1, 2)` и `List(3, 4)`, то резултатният списък ще бъде `List(f(1, 3), f(2, 4))`

Ако `a` и `b` са с различна дължина, то оставащите елементи на по-дългия списък се игнорират.

```scala
def zipMap(a: List[Int], b: List[Int], f: (Int, Int) => Int): List[Int]
```

Примери:

```scala
zipMap(List(1, 2, 3), List(4, 5, 6), _ * _) // List(4, 10, 18)
zipMap(List(3, 6), List(20, 30, 40), (x, y) => y - x) // List(17, 24)
```

## `countCoinChangeVariants` – Броене на възможностите да върнем ресто

Напишете функция, която брои всички възможни начини да върнем ресто (`change`) за определена сума, ако разполагаме с неизчерпаем източник на монети с определени деноминации (`denominations`). Сумата от използваните монети трябва да е точно равна на търсеното ресто.

Като пример, ако е необходимо да върнем ресто от 6 пари и разполагаме с монети с деноминации 1, 2 и 5, то имаме 5 начина да го постигнем (редът на монетите не е от значение):

```
1 + 1 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 2
1 + 1 + 2 + 2
2 + 2 + 2
1 + 5
```

Сигнатурата на функцията е следната:

```scala
def countCoinChangeVariants(denominations: List[Int], change: Int): Int

```

Елементите на `denominations` са уникални.

Пример:

```scala
countCoinChangeVariants(List(1, 2, 5), 6) // 5
```

## Опашка

Реализирайте неизменяема (immutable) опашка от цели числа със следните операции:

* `peek: Int` – връща елемента от началото на опашката. Ако опашката е празна хвърлете `NoSuchElementException` (изключения се хвърлят чрез `throw new <изключение>`)
* `push(n: Int): Queue` – връща нова опашка, с елемента `n` добавен в края на текущата
* `pop: Queue` – връща нова опашка, в която елемента в началото е премахнат. Ако опашката е празна хвърлете `NoSuchElementException`
* `isEmtpy: Boolean` – казва дали опашката е празна или не
* `size: Int` – връща броя на елементите на опашката

Оставяме вътрешната реализация на опашката и това как изглежда нейният конструктор на вас.

Допълнително реализирайте companion обект към опашката със следните два метода:

* `empty: Queue` – връща празна опашка
* `apply(xs: Seq[Int]): Queue` – създава опашка от подадената колекция (`List`, `Range`, `Vector` и други са наследници на `Seq`)

Декларацията на опашката изглежда по следния начин:

```scala
class Queue(/* ??? */) {
  def peek: Int = ???

  def push(n: Int): Queue = ???
  def pop: Queue = ???

  def isEmpty: Boolean = ???
  def size: Int = ???
}

object Queue {
  def empty: Queue = ???

  def apply(xs: Seq[Int]): Queue = ???
}
```

Ако желаете да скриета конструктора на опашката, можете да го направите по следния начин (companion обекта все още има достъп до него):

```scala
class Queue private (/* ??? */) { /* ... */}
```

**(бонус)** Помислете как може да имплементирате опашката ефективно. Ако постигнете константна или амортизирано константна сложност за операциите `peek`, `push`, `pop` и `isEmpty`, то ще получите бонус точка.

## `bfsTraversal` – Проследяване на обхождане в ширина _(бонус функция)_

Класическо приложение на опашка е за реализиране на търсене в ширина в граф. Като незадължителна бонус задача за упражнение, дефинирайте функция `bfsTraversal`, която да използва опашката, която реализирахте. Функцията приема начален и краен възел и функция, връщаща списък от съседите на подадения ѝ възел в ориентирания граф, в който се извършва търсенето. Вместо класическото приложение на алгоритъма (търсене на най-кратък път), ще искаме да проследим възлите, през които той минава, докато не намери търсения краен възел. Резултатът от `bfsTraversal` е опашка от реда на посещение на възлите, започваща със `start`, като в нея реда на посетените съседи трябва да съвпада с реда в списъка, върнат от `neighbours`. Ако алгоритъмът открие `end` то той трябва да е последният елемент от опашката, ако не, то резултатът е всички възли, които сте обходили докато алгоритъмът приключи търсенето.

Сигнатурата на функцията е следната:

```scala
def bfsTraversal(start: Int, end: Int, neighbours: Int => List[Int]): Queue
```

Графът може да не е дървовиден и затова за да избегнете повторно посещение на възел може да използвате [`Set`](https://www.scala-lang.org/api/current/scala/collection/immutable/Set.html) за да запазвате вече посетените.

Пример:

За графа

```

1 -> 2, 5, 8
2 -> 1, 3, 6
3 -> 2, 4
4 -> 3
5 -> 6
6 -> 7
8 -> 9
```

При начален възел 1 и краен 6 търсеният резултат е опашката от `1, 2, 5, 8, 3, 6`. При начален възел 4 и краен 6 резултатът е `4, 3, 2, 1, 6`.

## Допълнителни указания

Използвайте проекта, предоставен в тази директория. Попълнете скелета от пакета `homework1`. В `src/test/scala` може да намерите няколко теста. Насърчаваме ви да добавите собствени за да тествате вашите решения. 


## Оценяване

Всяка от функциите (включително `bfsTraversal`) и опашката ви носи по една точка (за общо 6). Ако реализирате опашката ефективно, то ще получите допълнителна бонус точка.

Очакваме от вас решения, които са написани и подредени в добър стил и не използват изменяемост (mutability). Като първо домашно няма да ви взимаме точки, ако не спазват напълно това (освен за крайни случаи), но за следващите домашни ще сме по-стриктни.

## Любопитно

* Ако искате вашата опашка да включва стандартните методи, които виждаме върху колекции, то тя трябва да имплементира trait-а [`Iterable[Int]`](https://www.scala-lang.org/api/current/scala/collection/Iterable.html). За целта е необходимо да предоставите имплементация на следния метод и ще получите наготово всички останали, като `map`, `filter`, `take` и т.н.
  
  ```scala
  def iterator: Iterator[Int]
  ```
  
  Забележете, че при това методи като `map` връщат `Iterable` вместо `Queue`, което съвпада с поведението на такъв тип интерфейси/mixin-и в други езици, но не и с това, което виждаме по другите колекции в Scala. По-късно в курса ще разгледаме как Scala ни позволява да връщаме конкретния тип (в случая `Queue`) вместо абстракцията, която имплементира.
* По време на лекция 5 ще разгледаме generic типови параметри. Чрез тях може да опитате да реализирате вашата опашка и функциите, използващи списък, за всички типове, а не само за `Int`. Опитайте се да отговорите на въпроса опашка от `Int` стойности може ли да бъде разглеждана като опашка от `AnyVal` стойности? На този въпрос ще отговорим по-късно в курса.
